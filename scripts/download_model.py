import os
import time

from typing import TypedDict, Optional, Literal, Union, List

import libtorrent as lt
import requests as rq

from cli_builder import CLI


class Model(TypedDict):
    description: str
    filename: str
    magnet_link: Optional[str]
    direct_link: Optional[str]

ModelList = List[Model]

model_list: ModelList = [
    {
        'description': 'You can treat v1.4 as a general-purpose model. Most of the time, it is enough to use it as is unless you are really picky about certain styles.',
        'filename': 'sd-v1-4.ckpt',
        'direct_link': 'https://huggingface.co/CompVis/stable-diffusion-v-1-4-original/resolve/main/sd-v1-4.ckpt',
        'magnet_link': None,
    },
    {
        'description': 'v1.5 is released in Oct 2022 by Runway ML, a partner of Stability AI. The model is based on v1.2 with further training.',
        'filename': 'v1-5-pruned-emaonly.ckpt',
        'direct_link': 'https://huggingface.co/runwayml/stable-diffusion-v1-5/resolve/main/v1-5-pruned-emaonly.ckpt',
        'magnet_link': 'magnet:?xt=urn:btih:3f8016061132ad4a475eb33dac569f3a88418974&dn=v1-5-pruned-emaonly.safetensors&tr=udp%3a%2f%2fopen.demonii.com%3a1337%2fannounce&tr=udp%3a%2f%2fexodus.desync.com%3a6969%2fannounce'
    },
    {
        'direct_link': 'https://huggingface.co/acheong08/f222/blob/main/f222.ckpt',
        'description': 'F222 is good for portraits. It has a high tendency to generate nudes. Include wardrobe terms like “dress” and “jeans” in the prompt.',
        'filename': 'f222.ckpt',
        'magnet_link': None,
    },
    {
        'direct_link': 'https://huggingface.co/Linaqruf/anything-v3.0/resolve/main/anything-v3-fp16-pruned.safetensors',
        'description': 'Anything V3 is a special-purpose model trained to produce high-quality anime-style images. You can use danbooru tags (like 1girl, white hair) in the text prompt.',
        'filename': 'anything-v3-fp16-pruned.safetensors',
        'magnet_link': None,
    },
    {
        'direct_link': 'https://huggingface.co/prompthero/openjourney/resolve/main/mdjrny-v4.ckpt',
        'description': 'Open Journey is a model fine-tuned with images generated by Mid Journey v4. It has a different aesthetic and is a good general-purpose model.',
        'filename': 'mdjrny-v4.ckpt',
        'magnet_link': None,
    },
    {
        'direct_link': 'https://civitai.com/api/download/models/5636?type=Pruned%20Model&format=SafeTensor',
        'description': 'Dreamshaper model is fine-tuned for a portrait illustration style that sits between photorealistic and computer graphics. It’s easy to use and you will like it if you like this style.',
        'filename': 'dreamshaper-v1.ckpt',
        'magnet_link': None,
    },
    {
        'direct_link': 'https://civitai.com/api/download/models/15236',
        'description': 'Deliberate v2 is another must-have model (so many!) that renders realistic illustrations. The results can be surprisingly good. Whenever you have a good prompt, switch to this model and see what you get!',
        'filename': 'deliberate-v2.ckpt',
        'magnet_link': None,
    },
    {
        'direct_link': 'https://civitai.com/api/download/models/29460',
        'description': 'Realistic Vision v2 is for generating anything realistic. Learn more about generating realistic people.',
        'filename': 'realistic-vision-v2.ckpt',
        'magnet_link': None,
    },
    {
        'direct_link': 'https://civitai.com/api/download/models/4007',
        'description': 'Protogen v2.2 is classy. It generates illustration and anime-style images with good taste',
        'filename': 'protogen-v2.2.ckpt',
        'magnet_link': None,
    }
]

DESTINATION = './input/model/'
LOGS_DIR = '/tmp/logs'

def to_byte_units(size: int):
    if size < 1024:
        return f"{size}B"
    elif size < 1024 * 1024:
        return f"{round(size / 1024, 2)}KB"
    elif size < 1024 * 1024 * 1024:
        return f"{round(size / 1024 / 1024, 2)}MB"
    else:
        return f"{round(size / 1024 / 1024 / 1024, 2)}GB"

def download_via_magnet_link(magnet_link: str, destination: str):
    ses = lt.session()
    h = lt.add_magnet_uri(ses, magnet_link, {'save_path': destination})

    print("Downloading the file {} to {} via magnet link...".format(h.name(), destination))

    while not h.is_seed():
        s = h.status()
        print(f"Progress: {s.progress * 100:.2f}%")
        time.sleep(1)

    print(f"Download complete. File saved to: {destination}/{h.name()}")

def download_via_direct_link(direct_link: str, destination: str, filename: str = ''):
    print("Downloading the file {} to {} via direct link...".format(filename, destination))

    r = rq.get(direct_link, allow_redirects=True, stream=True) ## print progress below

    total_length = int(r.headers.get('content-length', 0)) if 'content-length' in r.headers else None

    progress = 0
    with open(os.path.join(destination, filename), 'wb') as f:
        for chunk in r.iter_content(chunk_size=1024):
            progress = progress + len(chunk)
            f.write(chunk)

            if chunk and total_length:
                progress_bytes = to_byte_units(progress)
                total_length_bytes = to_byte_units(total_length)
                print(f"\rProgress: ({progress_bytes}/{total_length_bytes}) - {round(progress / total_length * 100, 2)}%", end='\r')
            if chunk and not total_length:
                print(f"\rProgress: {to_byte_units(progress)}", end='\r')

    print(f"Download complete. File saved to: {destination}/{filename}")

def download_model(
        model: Model,
        via: Union[Literal['direct'], Literal['magnet']] = 'direct',
        destination: str = '/tmp/input/models/',
    ):

    if via == 'direct' and model['direct_link']:
        download_via_direct_link(model['direct_link'], destination, model['filename'])
    elif via == 'magnet' and model['magnet_link']:
        download_via_magnet_link(model['magnet_link'], destination)
    

def show_models():
    for model in model_list:
        direct_link = f"Direct link: {model['direct_link']}\n" if model.get('direct_link') else ''
        magnet_link = f"Magnet link: {model['magnet_link']}\n" if model.get('magnet_link') else ''
        print(f"{model['filename']}\n{model['description']}\n{direct_link}{magnet_link}")

def main():
    args = CLI('Download models') \
            .list_models() \
            .model() \
            .output(DESTINATION, lambda args: not args.list_models) \
            .parse()
            
    if args.list_models:
        show_models()
        return
    
    if args.model:
        model = next((model for model in model_list if model['filename'] == args.model), None)

        if model:
            if os.path.exists(os.path.join(args.output or DESTINATION, model['filename'])):
                print('Model already exists')
                return

            try:
                download_model(model, via='direct', destination=args.output or DESTINATION)
            except KeyboardInterrupt:
                print('Download cancelled, deleting the file...')
                os.remove(os.path.join(args.output or DESTINATION, model['filename']))
            except Exception as e:
                print(e)
                print('Download failed, deleting the file...')
                os.remove(os.path.join(args.output or DESTINATION, model['filename']))

        else:
            print('Model not found')

if __name__ == '__main__':
    main()